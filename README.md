Damon Harris
06/27/2025
ReadMe
1. How Do I Approach Designing Software?
New Design Skills Gained:
•	3D shape creation using primitive meshes
•	Transformations (scaling, rotation, translation)
•	Real-time rendering with OpenGL
•	Mathematical modeling for motion
•	Understanding and using camera view space
•	Rendering sprites and managing animations
•	Detecting and managing object collisions
Design Process Followed:
For this project, I followed a structured design process:
1.	Planning: Defined the goal: animate a walking stick figure using OpenGL.
2.	Setup: Initialized the rendering environment with GLFW and GLAD.
3.	Prototyping: Built the figure using basic shapes to visualize the structure.
4.	Animation: Used time-based functions (glfwGetTime and sin) for leg movement and screen traversal.
5.	Refinement: Fine-tuned animation timing and swing angles for smoother motion.
6.	Modularization: Structured the code for scalability (e.g., adding more figures or textures).
This process kept the project organized, easy to test, and flexible for improvements.
Applying These Tactics to Future Work:
The strategies I used, breaking the project into components, using modular code, and applying time-based animation, are broadly applicable. They improve scalability, ease debugging, and make future expansions easier. For example, modular animation logic can be reused for sprite engines, and time-based functions ensure smooth animation regardless of hardware performance.

2. How Do I Approach Developing Programs?
Development Strategy:
I start by defining the program's purpose and breaking it down into manageable tasks. I first build a basic prototype to ensure the core logic works. Then I gradually add features, test frequently, and refine the code for clarity and performance. I prefer modular design because it improves reusability and simplifies updates. My workflow prioritizes logic and functionality before focusing on visuals or user interaction.
Role of Iteration in Development:
Iteration played a major role in my development process. I began with a static stick figure, then slowly integrated motion and animation. With each iteration, I tested the output and made improvements, adjusting leg swing, motion speed, and frame timing. This loop of testing and refining helped me build a smoother, more polished animation and improved my overall coding workflow.
How My Process Evolved:
At the beginning of the project, I focused on simply getting things to work. Over time, I adopted a more structured approach: organizing code into functions, separating logic into multiple files, and using time-based logic for smoother, frame-rate-independent animation. By the final milestone, I was comfortable debugging in real time and applying modular design principles to make the code cleaner and more scalable.

3. How Can Computer Science Help Me Reach My Goals?
Educational Pathway Impact:
Working with computational graphics gave me a strong foundation in how math, logic, and visuals combine in real-time applications. I gained experience with coordinate systems, spatial reasoning, animation techniques, and rendering principles. These skills directly support my future studies in game development, simulation, or computer vision. They also helped me build confidence in debugging and structuring interactive, visual systems.
Professional Pathway Impact:
Computational graphics and visualizations have taught me how to transform logic into interactive visual results. I've gained skills in real-time rendering, time-based animation, and scene management—valuable abilities in fields like software engineering, game development, and user interface design. These experiences improved my problem-solving, performance optimization techniques, and ability to create visually engaging, responsive applications.

